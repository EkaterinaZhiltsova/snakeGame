# План тестирования
## Описание функций
### Модуль game.py

#### \# Вычисление новых случайных координат для яблока на поле
```python
def random_food(controlled_snake_list, competitor_snake_list, width, height)  
    return foodx_coord, foody_coord
```

Аргументы функции: 
* controlled_snake_list – список (list, в котором каждый элемент – это list [x, y]) координат расположения всех блоков тела управляемой змеи (последний элемент списка [-1] – голова змеи)
* competitor_snake_list – список (list, в котором каждый элемент – это list [x, y]) координат расположения всех блоков тела змеи-противника (последний элемент списка [-1] – голова змеи), 
*	width – значение ширины игрового поля, внутри которого должны быть новые координаты яблока,
*	height – значение высоты игрового поля, внутри которого должны быть новые координаты яблока

Возвращаемые значения: foodx_coord – координата x расположения еды (яблока) на поле, foody_coord – координата y расположения еды (яблока)  на поле


#### \# Проверка окончания игры (проигрышной ситуации врезания в границы поля)
```python
def losing_situation(x, y)  
    return True/False
```

Аргументы функции: x – координата x змейки(головы) на поле, y – координата y змейки(головы) на поле

Возвращаемые значения: True – проигрыш (окончание игры)/False – игра продолжается (расположение змейки на данном шаге не проигрышное)

#### \# Проверка столкновения (проигрышной ситуации) змейки с самой собой или с противником (и наоборот)
```python
def collision_check(controlled_snake_list, competitor_snake_list)  
    return True/False
```

Аргументы функции: 
* controlled_snake_list – список (list, в котором каждый элемент – это list [x, y]) координат расположения всех блоков тела управляемой змеи (последний элемент списка [-1] – голова змеи)
* competitor_snake_list – список (list, в котором каждый элемент – это list [x, y]) координат расположения всех блоков тела змеи-противника (последний элемент списка [-1] – голова змеи)

Возвращаемые значения: True – проигрыш (окончание игры), одна из змеек столкнулась с самой собой/с другой змейкой/False – игра продолжается (расположение змейки на данном шаге не проигрышное, столкновения нет)

#### \# Проверка нахождения змейкой еды (увеличение счета)
```python
def find_food(food_x, food_y, length_of_controlled_snake, length_of_competitor_snake, controlled_snake_list, competitor_snake_list)  
    return True/False, length_of_controlled_snake, length_of_competitor_snake
```

Аргументы функции: 
* food_x – координата x расположения еды (яблока) на поле, 
* food_y – координата y расположения еды (яблока)  на поле,
* length_of_controlled_snake – длина управляемой змеи (количество блоков в теле) (int),
* length_of_competitor_snake – длина змеи-противника (количество блоков в теле) (int),
* controlled_snake_list – список (list, в котором каждый элемент – это list [x, y]) координат расположения всех блоков тела управляемой змеи (последний элемент списка [-1] – голова змеи)
* competitor_snake_list – список (list, в котором каждый элемент – это list [x, y]) координат расположения всех блоков тела змеи-противника (последний элемент списка [-1] – голова змеи)

Возвращаемые значения:
* True – одна из змей нашла еду -> начисление 1 очка нашедшей еду змее (увеличение длины тела на 1)/False – ни одна из змей не нашла еду (количество очков и длина тела сохраняется у обеих)
* length_of_controlled_snake – длина управляемой змеи (количество блоков в теле) (int),
* length_of_competitor_snake – длина змеи-противника (количество блоков в теле) (int)

#### \# Перемещение змеи на шаг (всех блоков тела) в координатах и увеличение длины, если змея заработала очко
```python
def move_snake_blocks(snake_list, x_coord, y_coord, length_of_snake)  
    return snake_list
```

Аргументы функции: 
* snake_list – список (list, в котором каждый элемент – это list [x, y]) координат текущего расположения всех блоков тела змеи (последний элемент списка – голова змеи), 
* x_coord – координата x нового расположения головы змейки на поле, на которое надо переместиться, 
* y_coord – координата y нового расположения головы змейки на поле, на которое надо переместиться, 
* length_of_snake – длина змейки (количество блоков в теле) (int)

Возвращаемые значения: snake_list – список (list, в котором каждый элемент – это list [x, y]) координат расположения всех блоков тела змеи (последний элемент списка [-1] – голова змеи)

#### \# Расчет следующего шага змеи-соперника
```python
def independent_snake_movement(food_x, food_y, competitor_snake_list, controlled_snake_list)  
    return x1_change, y1_change
```

Аргументы функции:
* food_x – координата x расположения еды на поле, 
* food_y – координата y расположения еды на поле, 
* competitor_snake_list – список (list, в котором каждый элемент – это list [x, y]) координат расположения всех блоков тела змеи-противника (последний элемент списка [-1] – голова змеи), 
* controlled_snake_list – список (list, в котором каждый элемент – это list [x, y]) координат расположения всех блоков тела управляемой змеи (последний элемент списка [-1] – голова змеи)

Возвращаемые значения: x1_change – вектор перемещения змеи-противника(головы) по оси x, y1_change – вектор перемещения змеи-противника(головы) по оси y

#### \# Основной цикл игры
```python
def game_loop(game_over=False)
```

Аргументы функции: game_over=False (дефолтное значение переменной – игра не окончена)

Возвращаемые значения: –

> Функция не тестируется, так как отвечает лишь за отслеживание нажатий пользователя на клавиатуру и вызов других функций (которые тестируются отдельно), не содержит в себе логики.

### Модуль drawing.py

#### \# Отрисовка счета (для обеих змеек) на экране игры
```python
def show_scores(score1, score2, dis, dis_height, dis_width)
```

Аргументы функции: score1 – значение счета управляемой змейки, score2 – значение счета змейки-противника, dis – область отрисовки, dis_height – высота поля отрисовки, dis_width – ширина поля отрисовки

Возвращаемые значения: –

> Функция не тестируется, так как отвечает лишь за отрисовку объектов, не содержит в себе логики и не может привести к ошибкам.

#### \# Отрисовка счета (для одной змейки) на экране игры
```python
def show_score(score, color, text, x_coord, score_font, dis)
```

Аргументы функции: score – значение счета змейки, color – цвет отрисовки, text – текст для вывода, x_coord – координата x размещения надписи, score_font – шрифт, dis – область отрисовки

Возвращаемые значения: –

> Функция не тестируется, так как отвечает лишь за отрисовку объектов, не содержит в себе логики и не может привести к ошибкам.

#### \# Вывод сообщения на экран игры
```python
def message(msg, x_coord, y_coord, dis)
```

Аргументы функции: msg – текст сообщения, x_coord – координата x размещения надписи, y_coord – координата y размещения надписи, dis – область отрисовки

Возвращаемые значения: –

> Функция не тестируется, так как отвечает лишь за отрисовку объектов, не содержит в себе логики и не может привести к ошибкам.

#### \# Отрисовка змей на экране игры
```python
def draw_snakes(snake_block, controlled_snake_list, competitor_snake_list, dis)
```

Аргументы функции: snake_block – размер одного блока тела змеи, controlled_snake_list – список (list, в котором каждый элемент – это list [x, y]) координат расположения всех блоков тела управляемой змеи, competitor_snake_list – список (list, в котором каждый элемент – это list [x, y]) координат расположения всех блоков тела змеи-противника, dis – область отрисовки

Возвращаемые значения: –

> Функция не тестируется, так как отвечает лишь за отрисовку объектов, не содержит в себе логики и не может привести к ошибкам.

#### \# Отрисовка змеи (каждого блока) на экране игры
```python
def draw_snake(snake_block, snake_list, color, dis)
```

Аргументы функции: snake_block – размер одного блока тела змеи, snake_list – список (list, в котором каждый элемент – это list [x, y]) координат расположения всех блоков тела змеи, color – цвет отрисовки, dis – область отрисовки

Возвращаемые значения: –

> Функция не тестируется, так как отвечает лишь за отрисовку объектов, не содержит в себе логики и не может привести к ошибкам.

#### \# Отрисовка фона
```python
def draw_background(dis)
```

Аргументы функции: dis – область отрисовки

Возвращаемые значения: –

> Функция не тестируется, так как отвечает лишь за отрисовку объектов, не содержит в себе логики и не может привести к ошибкам.

#### \# Отрисовка основных объектов
```python
def draw_field(foodx, foody, snake_block, dis)
```

Аргументы функции: foodx – координата x расположения еды на поле, foody – координата y расположения еды на поле, snake_block – размер одного блока тела змеи, dis – область отрисовки

Возвращаемые значения: –

> Функция не тестируется, так как отвечает лишь за отрисовку объектов, не содержит в себе логики и не может привести к ошибкам.


## Тесты
### Блочные тесты:
1.	Блочный тест на функцию random_food (позитивный)  
def test_random_food_positive(self)  
Проверка assertTrue(): True – функция выдает подходящие случайные значения для размещения еды внутри игрового поля  
Входные данные: [[720.0, 250.0], [730.0, 250.0]],
                                  [[560.0, 160.0], [560.0, 150.0], [570.0, 150.0], [570.0, 140.0]], 600, 400  
Ожидаемый результат: True  
Тест пройден  

2.	Добавить тест с неправильным размером поля (негативный)  
def test_random_food_negative(self):  
Проверка assertTrue(): True – функция выдает подходящие случайные значения для размещения еды внутри игрового поля, указанного в значениях width и height  
Входные данные: [[720.0, 250.0], [730.0, 250.0]],
                                  [[560.0, 160.0], [560.0, 150.0], [570.0, 150.0], [570.0, 140.0]], width, height  
Ожидаемый результат: True  
Тест пройден  

3.	Блочный тест на функцию losing_situation (позитивный)  
def test_not_losing_situation_positive(self)  
Проверка assertFalse():False – ситуация не проигрышная  
Входные данные: 200, 300  
Ожидаемый результат: False  
Тест пройден  

4.	Блочный тест на функцию losing_situation (позитивный)  
def test_not_losing_situation_positive_2(self)  
Проверка assertFalse():False – ситуация не проигрышная (краевой случай)  
Входные данные: 590, 390  
Ожидаемый результат: False  
Тест пройден  

5.	Блочный тест на функцию losing_situation (негативный)  
def test_losing_situation_negative(self)  
Проверка assertTrue ():True - ситуация проигрышная (краевой случай)  
Входные данные: 600, 400  
Ожидаемый результат: True  
Тест пройден  

6.	Блочный тест на функцию losing_situation (негативный)  
def test_losing_situation_negative_2 (self)  
Проверка assertTrue ():True - ситуация проигрышная (краевой случай)  
Входные данные: -10, -10  
Ожидаемый результат: True  
Тест пройден  

7.	Блочный тест на функцию collision_check (позитивный)  
def test_not_collision_check_positive(self)  
Проверка assertFalse():False – ситуация не проигрышная (Змейки не врезаются)  
Входные данные: [[230.0, 350.0]], [[290.0, 370.0], [290.0, 380.0]]  
Ожидаемый результат: False  
Тест пройден  

8.	Блочный тест на функцию collision_check (негативный)  
def test_collision_check_negative_1(self)  
Проверка assertTrue ():True - ситуация проигрышная (Управляемая змейка врезалась в противника)  
Входные данные: [[280.0, 350.0]], [[280.0, 360.0], [280.0, 350.0], [280.0, 340.0]]  
Ожидаемый результат: True  
Тест пройден  

9.	Блочный тест на функцию collision_check (негативный)  
def test_collision_check_negative_2(self)  
Проверка assertTrue ():True - ситуация проигрышная (Управляемая змейка врезалась в себя)  
Входные данные: [[150.0, 200.0], [150.0, 210.0], [150.0, 220.0], [160.0, 220.0], [160.0, 210.0], [150.0, 210.0]], 
[[210.0, 170.0], [220.0, 170.0], [220.0, 160.0], [230.0, 160.0], [240.0, 160.0], [250.0, 160.0], [260.0, 160.0], [270.0, 160.0], [280.0, 160.0], [290.0, 160.0]]  
Ожидаемый результат: True  
Тест пройден  

10.	Блочный тест на функцию collision_check (негативный)  
def test_collision_check_negative_3(self)  
Проверка assertTrue ():True - ситуация проигрышная (Змейка противник врезалась в себя)  
Входные данные: [[210.0, 170.0], [220.0, 170.0], [220.0, 160.0], [230.0, 160.0], [240.0, 160.0], [250.0, 160.0], [260.0, 160.0], [270.0, 160.0], [280.0, 160.0], [290.0, 160.0]], 
[[150.0, 200.0], [150.0, 210.0], [150.0, 220.0], [160.0, 220.0], [160.0, 210.0], [150.0, 210.0]]  
Ожидаемый результат: True  
Тест пройден  

11.	Блочный тест на функцию collision_check (негативный)  
def test_collision_check_negative_4(self)  
Проверка assertTrue ():True - ситуация проигрышная (Змейка противник врезалась в управляемую)  
Входные данные: [[280.0, 360.0], [280.0, 350.0], [280.0, 340.0]], [[280.0, 350.0]]  
Ожидаемый результат: True  
Тест пройден  

12.	Блочный тест на функцию find_food (позитивный)  
def test_find_food_positive(self)  
Проверка assertEqual() – Змейка (в данном тесте управляемая, но они аналогично) нашла еду (координаты головы совпали с координатой еды)  
Входные данные: 400.0, 160.0, 1, 1, [[400.0, 160.0]], [[350.0, 200.0]]  
Ожидаемый результат: True, 2, 1  
Тест пройден  

13.	Блочный тест на функцию find_food (негативный)  
def test_find_food_negative(self)  
Проверка assertEqual() – Змейка не нашла еду (координаты головы не совпали с координатой еды)  
Входные данные: 150.0, 210.0, 1, 3, [[580.0, 200.0]], [[310.0, 380.0], [310.0, 370.0], [300.0, 370.0]]  
Ожидаемый результат: False, 1, 3  
Тест пройден  

14.	Блочный тест на функцию move_snake_blocks (позитивный)  
def test_move_snake_blocks_positive(self)  
Проверка assertEqual()  
Входные данные: [[120.0, 90.0], [120.0, 80.0]], 130.0, 80.0, 3  
С увеличением длины при добавлением очка  
Ожидаемый результат: [[120.0, 90.0], [120.0, 80.0], [130.0, 80.0]]  
Тест пройден  

15.	Блочный тест на функцию move_snake_blocks (позитивный)  
def test_move_snake_blocks_positive_2(self)  
Проверка assertEqual()  
Входные данные: [[100.0, 140.0], [100.0, 130.0]], 100.0, 120.0, 2  
Без увеличения длины без добавления очка  
Ожидаемый результат: [[100.0, 130.0], [100.0, 120.0]]  
Тест пройден  

16.	Блочный тест на функцию move_snake_blocks (негативный)  
Проигрыш при шаге за поле (выход за пределы поля без добавления очка)  
def test_move_snake_blocks_negative(self)  
Проверка assertEqual()  
Входные данные: [[580.0, 110.0], [590.0, 110.0]], 600.0, 110.0, 2  
Ожидаемый результат: [[590.0, 110.0], [600.0, 110.0]]  
Тест пройден  

17.	Блочный тест на функцию move_snake_blocks (негативный)  
Змейка занимает всё поле и выходит за него (при добавлении очка)  
def test_move_snake_blocks_negative_2(self)  
Проверка assertEqual()  
Входные данные: full_screen_snake_list, 400.0, 0.0, len(full_screen_snake_list) + 1)  
Ожидаемый результат: full_screen_snake_list_new  
Тест пройден  

18.	Блочный тест на функцию independent_snake_movement (позитивный)  
С mock-объектом на вызываемую функцию losing_situation  
def test_unit_independent_snake_movement_positive(self)  
Проверка assertEqual()  
Входные данные: 180.0, 310.0, [[150.0, 270.0], [150.0, 280.0]], [[600.0, 200.0]]  
Ожидаемый результат: (10, 0)  
Тест пройден  

19.	Блочный тест на функцию independent_snake_movement (негативный)  
С mock-объектом на вызываемую функцию losing_situation  
def test_unit_independent_snake_movement_negative(self)  
Проверка assertEqual()  
Входные данные:   
20.0, 90.0, 
[[430.0, 220.0], [440.0, 220.0], [440.0, 230.0], [450.0, 230.0], [450.0, 240.0], [460.0, 240.0], [460.0, 250.0], [470.0, 250.0], [470.0, 260.0], [480.0, 260.0], [480.0, 270.0], [490.0, 270.0], [490.0, 280.0], [500.0, 280.0], [500.0, 290.0], [490.0, 290.0], [480.0, 290.0], [470.0, 290.0], [460.0, 290.0], [450.0, 290.0], [440.0, 290.0], [430.0, 290.0], [420.0, 290.0], [410.0, 290.0], [400.0, 290.0], [390.0, 290.0], [390.0, 280.0], [390.0, 270.0], [390.0, 260.0], [390.0, 250.0], [400.0, 250.0], [400.0, 240.0], [410.0, 240.0], [410.0, 230.0], [420.0, 230.0], [420.0, 240.0], [420.0, 250.0], [410.0, 250.0], [410.0, 260.0], [400.0, 260.0], [400.0, 270.0], [400.0, 280.0], [410.0, 280.0], [410.0, 270.0], [420.0, 270.0], [420.0, 260.0], [430.0, 260.0], [430.0, 250.0], [430.0, 240.0], [430.0, 230.0], [430.0, 230.0]], 
[[400.0, 200.0]]  
Ожидаемый результат: (0, 0) -> нет возможных перемещений  
Тест пройден  


### Интеграционные тесты:

1.	Интеграционный тест на функцию independent_snake_movement (позитивный)  
def test_integration_independent_snake_movement_positive(self)  
Взаимодействие: функция independent_snake_movement -> вызываемая функция losing_situation  
Проверка assertEqual()  
Входные данные: 230.0, 50.0, [[260.0, 90.0], [260.0, 80.0], [250.0, 80.0]], [[400.0, 200.0]]  
Ожидаемый результат: (0, -10)  
Тест пройден  

2.	Интеграционный тест на функцию independent_snake_movement (негативный)  
def test_integration_independent_snake_movement_negative(self)  
Взаимодействие: функция independent_snake_movement -> вызываемая функция losing_situation  
Проверка assertEqual()  
Входные данные: 
310.0, 230.0, 
[[430.0, 80.0], [440.0, 80.0], [440.0, 70.0], [430.0, 70.0], [420.0, 70.0], [420.0, 80.0], [410.0, 80.0], [410.0, 90.0], [400.0, 90.0], [400.0, 100.0], [390.0, 100.0], [380.0, 100.0], [370.0, 100.0], [360.0, 100.0], [350.0, 100.0], [340.0, 100.0], [330.0, 100.0], [320.0, 100.0], [310.0, 100.0], [310.0, 90.0], [320.0, 90.0], [330.0, 90.0], [340.0, 90.0], [350.0, 90.0], [360.0, 90.0], [370.0, 90.0], [380.0, 90.0], [390.0, 90.0], [390.0, 80.0], [380.0, 80.0], [370.0, 80.0], [360.0, 80.0], [350.0, 80.0], [340.0, 80.0], [330.0, 80.0], [320.0, 80.0], [310.0, 80.0], [310.0, 70.0], [320.0, 70.0], [330.0, 70.0], [340.0, 70.0], [350.0, 70.0], [360.0, 70.0], [370.0, 70.0], [380.0, 70.0], [390.0, 70.0], [400.0, 70.0], [400.0, 80.0], [400.0, 80.0]], 
[[400.0, 200.0]]  
Ожидаемый результат: (0, 0) -> нет возможных перемещений  
Тест пройден  


### Аттестационные тесты:
1.	Тест A1(позитивный)  
Начальное состояние: игра не открыта  
Действие: пользователь запускает игру  
Ожидаемый результат: появляется экран игры “Змейка” (на экране 2 змейки и яблоко), змейка противник начинает двигаться за яблоком, управляемая змейка ждёт сигнал управления с клавиатуры  
Тест проверяет запуск игры  

2.	Тест A2(позитивный)  
Начальное состояние: игра запущена  
Действие: пользователь нажимает на крестик – закрытие окна игры  
Ожидаемый результат: окно игры закрывается  
Тест проверяет закрытие игры в любой момент работы игры при нажатии на крестик  

3.	Тест A3(позитивный)  
Начальное состояние: игра запущена  
Действие: пользователь нажимает на стрелку (вправо/влево/вверх/вниз) на клавиатуре  
Ожидаемый результат: управляемая (фиолетовая) змейка двигается в соответствии с выбранным направлением  
Тест проверяет реакцию игры на действия пользователя (нажатия на стрелки)  

4.	Тест A4(позитивный)  
Начальное состояние: игра запущена  
Действие: голова управляемой змейки (или змейки соперника аналогично) попадает на клетку с яблоком  
Ожидаемый результат: змейке, которая поймала яблоко начисляется очко, яблоко появляется в другой случайной клетке поля  
Тест проверяет реакцию игры на то, что змейка поймала яблоко  

5.	Тест A5(негативный)  
Начальное состояние: игра запущена  
Действие: голова управляемой змейки (или змейки соперника аналогично) выходит за пределы поля или врезается в своё тело или в тело другой змейки  
Ожидаемый результат: игра заканчивается, выигрывает змейка, у которой на момент окончания игры было очков (соответствующие надписи выводятся на экран игры)  
Тест проверяет реакцию игры на проигрыш (конец игры)  

6.	Тест A6(позитивный)  
Начальное состояние: игра запущена, на экране заголовки об окончании игры  
Действие: пользователь нажимает на клавишу C на клавиатуре  
Ожидаемый результат: начинается новая игра  
Тест проверяет реакцию игры на запуск новой игры после проигрыша (окончания игры)  

7.	Тест A7(позитивный)  
Начальное состояние: игра запущена, на экране заголовки об окончании игры  
Действие: пользователь нажимает на клавишу Q на клавиатуре  
Ожидаемый результат: окно игры закрывается  
Тест проверяет закрытие игры после проигрыша (окончания игры) по нажатию клавиши  
